#### 一、Java基础

##### 1 注意事项和细节

>  一个源文件最多只有一个public类(也可以没有)，其它类的个数不限

`代码：org.example.Hello`

当执行Hello类中的main方法后，编译后会生成 `Hello.class`、`Dog.class`、`Cat.class` 三个class文件

> 如果源文件包含一个public类，则文件名必须按该类名命名

###### 1.1 小思考

```markdown
问：Java多个类写到同一个文件和分开写有什么好处呢？
答：有好处和弊端，
好处：方便管理，比如Dog和Cat类写在了Hello类中，而一个文件只能有一个类使用public修饰，所以Dog和Cat不能使用public修饰，所以只能在本包内使用，在其他包无法使用，刚好这两个类我们也仅仅设计成只能 Hello类 来访问，所以这时写到一个文件中。

弊端：不能被其他包的类访问，不方便后续扩展。
```

###### 1.2 学习新技术的方法：

```markdown
1、先学习基本原理和基本语法（不要考虑细节）
2、快速入门案例（基本程序，crud）
3、考虑研究技术的注意事项，使用细节，使用规范，如何优化
```

##### 2 转义字符

###### 2.1 java 常用的转义字符

```markdown
1. \t：一个制表位，实现对齐功能
2. \n：换行符
3. \\：一个\
4. \ "：一个"
5. \ '：一个'
6. \r：一个回车
```

`org.example.ChangeChar`

###### 2.2 转义字符练习

`org.example.ChangeCharExer01`

##### 3 注释

###### 3.1 介绍

用于注解说明**解释程序的文字**就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良好变成习惯。将自己的思想通过注释先整理出来，再用代码去实现。

Java中的注释类型

- 单行注释
- 多行注释
- 文档注释 

###### 3.2 注释使用

```markdown
【单行注释】
	格式：//注释的文字

【多行注释】
	格式：/* 注释的文字 */
	
【使用细节】
1、被注释的文字，不会被JVM解释执行
2、多行注释里面不允许哟多行注释嵌套
```

###### 3.3 文档注释

```markdown
注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类。
```

`org.example.Comment02`

生成文档命令：wing@WangShaoYoudeMacBook-Pro example % javadoc -d temp -author -version Comment02.java

生成的文档保存在temp目录下，可以直接点开目录里的index.html就能访问到刚才生成的文档了。

| 标签          | 描述                                                 | 示例                                                         |
| ------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| @author       | 标识一个类的作者                                     | @author description                                          |
| @deprecated   | 指明一个过期的类或成员                               | @deprecated description                                      |
| {@docRoot}    | 指明当前文档根目录的路径                             | Directory Path                                               |
| @exception    | 标志一个类抛出的异常                                 | @exception exception-name explanation                        |
| {@inheritDoc} | 从直接父类继承的注释                                 | Inherits a comment from the immediate superclass             |
| {@link}       | 插入一个到另一个主题的链接                           | {@link name text}                                            |
| {@linkplain}  | 插入一个到另一个主题的链接，但是该链接显示纯文本字体 | Inserts an in-line link to another topic.                    |
| @param        | 说明一个方法的参数                                   | @param parameter-name explanation                            |
| @return       | 说明返回值类型                                       | @return explanation                                          |
| @see          | 指定一个到另一个主题的链接                           | @see anchor                                                  |
| @serial       | 说明一个序列化属性                                   | @serial description                                          |
| @serialData   | 说明通过writeObject()和writeExternal()方法写的数据   | @serialData description                                      |
| @serialField  | 说明一个ObjectStreamField组件                        | @serialField name type description                           |
| @since        | 标记当引入一个特定的变化时                           | @since release                                               |
| @throws       | 和 @exception标签一样                                | The @throws tag has the same meaning as the @exception tag.  |
| {@value}      | 显示常量的值，该常量必须是static属性                 | Displays the value of a constant,which must be a statuc field |
| @version      | 指定类的版本                                         | @version info                                                |

###### 3.4 Java代码规范

1. 类、方法的注释，要以javadoc的方式来写
2. 非java Doc的注释，往往是给代码的维护者看的，着重告诉读者为什么要这样写，如何修改，注意什么问题等。（那反过来JavaDoc的注释是给使用者看的，使用者只要知道怎么使用就行）
3. 运算符和 = 两边习惯性各加一个空格，比如 int i = 1 + 2 * 3;
4. 源文件使用utf-8编码
5. 行宽度不要超过80字符
6. 代码编写`次行风格`和`行尾风格`

```java
// 行尾风格(推荐)
public void test{
  
}

// 次行风格
public void test
{
  
}
```

 ##### 4 变量

###### 4.1 变量介绍

变量是程序的基本组成单位

变量有三个基本要素（类型 + 名称 + 值 ）



###### 4.2 +号的使用

1. 当左右两边都是数值类型时，做加法运算
2. 当左右两边有一方为字符串，做拼接运算



###### 4.3 基本数据类型

每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间（字节）

Java数据类型分为两大类：`基本数据类型`和`引用数据类型`

- `基本数据类型`：有8种，`数值型`[byte,short,int long,float,double] `字符型`[char], `布尔型`[boolean]
- `引用类型`：类、接口、数组

| 类型         | byte[字节] | short[短整型]                 | int[整型]                               | long[长整型] | float | double | boolean | char  |
| ------------ | ---------- | ----------------------------- | --------------------------------------- | ------------ | ----- | ------ | ------- | ----- |
| 占用存储空间 | 1字节      | 2字节                         | 4字节                                   | 8字节        | 4字节 | 8字节  | 1字节   | 2字节 |
| 范围         | -128～127  | -2^15~2^15-1【-32768～32767】 | -2^31~2^31-1【-2147483648～2147483647】 | -2^63~2^63-1 |       |        |         |       |

> 小思考

```markdown
问：如果我的数很大，long也存不进去怎么办呢？
答：可以使用 BigInteger、BigDecimal
```

> 整型的使用细节

- Java各整数类型有固定的范围和字段长度，不受具体OS（操作系统）的影响，以保证Java程序的可移植性
- Java的整型常量默认为int类型（比如直接在代码写 5），声明long类型常量须后加'l'或'L'，建议使用大些L，因为小写和数字1不好区分
- Java程序中变量常声明为int类型，除非不足以表示大数，才使用long
- bit：计算机中的`最小存储单位`，byte：计算机中`基本存储单元`，1byte = 8 bit。

> 浮点类型

| 类型          | 占用存储空间 | 范围                   |
| ------------- | ------------ | ---------------------- |
| 单精度float   | 4字节        | -3.403E38 ~ 3.403E38   |
| 双精度doouble | 8字节        | -1.798E308 ~ 1.798E308 |

说明：

- 关于浮点数在机器中存放形式的简单说明，`浮点数 = 符号位 + 指位数 + 尾位数`
- 尾数部分可能丢失，造成精度损失（小数都是近似值）

> 浮点型的使用细节

- Java的浮点型常量默认为double类型（比如直接在代码写 5.1，见下面演示），声明float类型常量须后加'f'或'F'，建议使用大些F
- 浮点型常量有`两种表示形式`

​       十进制数形式：如：5.12、  512.0f    .512（必须有小数点，见下面演示）

​       科学计数法形式：如：5.12e2[5.12 * 10的2次方].   5.12E-2[5.12 / 10的2次方]

- 通常情况下，应该使用double型，因为它比float型更精确
- 浮点数使用陷进：2.7 和 8.1/3 比较

> 演示

```java
public class Test{
  public static void main(String[] args){
    float num1 = 1.1; // 这里错误，因为浮点型常量默认为double类型，应该这样写 float num1 = 1.1F
    double num2 = .512; // 正确，.512等价于 0.512 0可以省略
    System.out.println(5.12e2); // 512.0
    System.out.println(5.12E-2); // 0.0512
    
    // 比较 double 和 float 的精度
    double num9 = 2.1234567851;
    float num10 = 2.1234567851F;
    System.out.println(num9); //  2.1234567851 (全部能输出，精度更高)
    System.out.println(num10); //  2.1234567  (部分输出，精度比double低)
  }
}
```

> 字符类型

> 字符类型的使用细节

- 字符常量是用单引号（''）括起来的单个字符。例如：char c1 = 'a'; char c2 = '王';
- java中还允许使用转义字符'\'来将其后的字符转变为特殊字符型常量。例如： char c3 = '\n'；
- 在Java中，char的本质是一个整数，在输出时，是 Unicode码对应的字符，要输出对应的数字，可以(int)字符，见下面演示
- char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码

> 演示

```java
public class Test{
  public static void main(String[] args){
    char c1 = 'a';
    char c2 = '\t';
    char c3 = '王';
    char c4 = 97;
    System.out.println(c1); // a
    System.out.println(c2); // 
    System.out.println(c3); // 王
    System.out.println(c4); // a   [会输出97表示的字符]
    System.out.println((int)c1); // 97
  }
}
```



字符类型可以使用单个字符，字符类型是char，char是两个字节（可以存放汉字），多个字符使用字符串String



> 布尔类型

- 布尔类型也叫boolean类型，boolean类型数据只允许取值 true 和 false，无 null
- boolean 类型占用 1 个字节
- boolean 类型适用于逻辑运算，一般用于程序流程控制（if、while、do-while、for）

###### 4.4 编码

> 字符编码表

- ASCII(ASCII编码表，`一个字节`表示，一共 128 个字符，实际上一个字节可以表示 256 个字符，只用了 128个)
- Unicode(Unicode编码表固定大小的编码，使用两个字节来表示字符，字母和汉字统一都是占用两个字节，这样浪费空间)
- Utf-8（编码表，大小可变的编码，字母使用1个字节，汉字使用3个字节）
- Gbk（可以表示汉字，而且范围广，字母使用1个字节，汉字2个字节）
- Gb2312(可以表示汉字，gb2312 < gbk，用得少，了解)
- big5码（繁体中文，台湾，香港）

> 小思考

```markdown
问：有了ASCII为什么还要用Unicode呢？
答：因为一开始只有美国人用，美国只有字母 ASCII 128 就够表示了，但是这时中国人也要用，那128不够用了（其他国家也是一样不够用），即使使用一个字节用满 256 个也不够用了，所以机构出来了重新设计了一个在ASCII标准下的另一个标准 Unicode（使用两个字节来表示）。
Unicode码兼容ASCII码（比如a在Unicode表示97，在ASCII码中也是）

补充：utf-8也是在Unicode之上进行的改进，因为Unicode都是使用的两个字节表示（字母也是），而utf-8变得更加灵活了（字母使用1个字节，汉字使用3个字节表示）

补充：相同的一个.java文件，如果文件里面的内容仅仅就是 “abc王”,如果保存该文件使用不同的编码方式保存，那么文件的大小也不一样，如果使用utf-8保存，那么文件大小为：6字节；如果使用gbk保存相同的文件，那么文件大小为：5字节；

补充：如果有一个文件里面很极端，内容是 aabbccaabbccaabbccaabbcc王aabbccaabbcc，很长的内容里面只有一个汉字，如果使用Unicode编码，那么这就很浪费存储空间了,文件就会变得很大，因为不管字母还是汉字都是使用2个字节来表示；但此时使用utf-8好处就出现了，这时字母只需要1个字节，汉字3个字节，也因为汉字使用3子字节表示，所以能表示的范围更多了，gbk虽然字母也使用一个字节，但是汉字使用两个字节，表示的范围没有utf-8范围广。

补充：utf-8是一种变长的编码方式，它可以使用 1-6 个字节来表示一个符号，根据不同的符号而变化字节长度。
```



###### 4.5 基本数据类型转换

> 自动类型转换

当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的类型，这个就是`自动类型转换`

数据类型按精度（容量）大小排序为：

1. char  < int < long < float < double ;
2. byte < short  < int < long < float < double ;

```java
int num = 'a';   // ok  char -> int
double d1 = 80;  // ok  int -> double
```

> 自动类型转换注意和细节

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
2. 当我们把精度大的数据类型赋值给精度小的数据类型时，会出错；反之小的赋值给大的就会进行自动类型转换。
3. byte,short和char之间不会相互自动转换
4. byte, short,char 他们三者可以计算，在计算时首先转换为int类型
5. boolean,不参与运算
6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

```java
int n1 = 10;  
float d1 = n1 + 1.1;  // 错误，按照上面的第一点原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
分析：n1 是 int 类型； 1.1是double类型（没写后缀L或D，默认double），两者运算转成最大的double进行运算，最终结果为double类型，所以不能直接赋值给float
  
// 如果就是想使用float接收呢，可以
float d1 = n1 + 1.1F; 
float d1 = float(n1 + 1.1); 

byte b1 = 10;  // -128 ～ 127，ok，为什么呢，10不是int类型吗，怎么能赋值给 byte类型呢
// 解答：当把具体的数赋值给byte类型时，编译器会先判断该数是否在byte范围内，如果是就可以

int n2 = 1;
byte b2 = n2; // 错误，原因：如果是变量赋值，判断类型

//byte,short和char之间不会相互自动转换
byte b1 = 10;
char c1 = b1; // 错误，原因：byte不能自动转成char


//byte, short,char 他们三者可以计算，在计算时首先转换为int类型
byte b2 = 1;
byte b3 = 2;
short s1 = 1;
short s2 = b2 + s1; // 错误，原因：运算时已经提升为了int类型

byte b4 = b2 + b3; //错误，原因：只要有byte, short,char 他们三者参与了计算，都会提升为int，所以b2 + b3 最终类型为 int ，所以不行
```



> 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意。

```java 
int n1 = (int)1.9;
System.out.println("n1=" + n1);// 结果：n1=1；精度损失，所以要格外注意

int n2 = 2000;
byte b1 = (byte)n2;
System.out.println("b1=" + b1);//结果b1=-48；数据溢出，并不是想象的 128

// char类型可以保存int的常量值，但不能保存int的变量值，需要强转
char c1 = 100;
int m = 100;
char c2 = m; // 错误
char c3 = (char)m;  // ok
System.out.println(c3);

// 强转符号只针对最近的操作数有效，往往会使用小括号提升优先级
int n1 = (int)10 * 3.5 + 6 * 1.1; // 编译错误
int n1 = (int)(10 * 3.5 + 6 * 1.1); // ok
```



######  4.6 基本数据类型和String类型转换

程序开发中，我们经常需要将基本数据类型转成String类型，或者将String类型转成基本数据类型。

> 基本数据类型转Sting类型，后面加 ""就能转成功

```java
int n1 = 100;
float f1 = 1.1F;
double d1 = 4.5;
boolean b1 = true;

String s1 = n1 + "";  // 100
String s2 = f1 + "";  // 1.1
String s3 = d1 + "";  // 4.5
String s4 = b1 + "";  // true
```



> String类型转成基本数据类型，使用parseXX()；

```java
String str = "123";
byte b1 = Byte.parseByte(str); // 123
short s1 = Short.parseShort(str); // 123
int num1 = Integer.parseInt(str);  // 123
long lo1 = Long.parseLong(str);  // 123
float f1 = Float.parseFloat(str); // 123.0
double d1 = Double.parseDouble(str); // 123.0
boolean boo = Boolean.parseBoolean("true"); // true

// 怎么把String转成char呢？因为char只能有一个字符,取索引，所以转换方式如下
char ch = str.charAt(2); // 3
```



 ##### 5 运算符

###### 5.1 运算符介绍

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。



###### 5.2 算术运算符

算术运算符是对数值类型的变量进行运算的，在Java程序中使用的非常多。

算数运算符包含： + ，-，*，/，%，++，--

```java
System.out.println( 10 /4);  // 数学角度等于2.5，但是这里是得到一个int类型，所以等于 2
System.out.println( 10.0 /4);  // 等于 2.5，因为最终结果是double类型
double d = 10 / 4;
System.out.println( d );  // 等于 2.0,因为最终结果为int，int赋值给double

// 取模（取余）【重点公式】
// % 的本质，看一个公式： a % b = a - a / b * b   
// 比如求  -10.5%3 = ？ 重点：  a % b当a是小数时，公式 =  a - (int)a / b * b  
// -10.5 - (int)(-10.5) / 3 * 3 = -1.5(注意：有小数参与的运算得到的结果是近似值，比如：-10.4%3)

// -10 % 3 = -10 -（-10）/ 3 * 3 = -1
// 10 % -3 = 10 -（10）/(-3) * (-3) = 1
// -10 % -3 = -10 -（-10）/(-3) * (-3) = -1
System.out.println( 10 % 3);  // 1
System.out.println( -10 % 3);  // -1
System.out.println( 10 % -3);  // 1
System.out.println( -10 % -3);  // -1
```

###### 5.3 关系运算符

关系运算符包含： ==，!=，<，>，<=，>=，instances（检查是否类的对象）



###### 5.4 逻辑运算符

用于连接多个条件（多个关系表达式）,最终的结果也是一个boolean值

逻辑运算符包含：&(逻辑与)，|(逻辑或)，^(逻辑异或)，&&(短路与)，||(短路或)，！(取反)

| a     | b     | a&b   | a&&b  | a\|b  | a\|\|b | !a    | a^b   |
| ----- | ----- | ----- | ----- | ----- | ------ | ----- | ----- |
| true  | true  | true  | true  | true  | true   | false | false |
| true  | false | false | false | true  | true   | false | true  |
| false | true  | false | false | true  | true   | true  | true  |
| false | false | false | false | false | false  | true  | false |

```java
boolean x = true;
boolean y = false;
short z = 46;
if((z++==46)&&(y=true)){ // true && true
    z++;
}
if((x=false)||(++z==49)){// false || true
    z++;
}
System.out.println(z); // 50
```



###### 5.5 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量

基本赋值运算符： = 

复合赋值运算符：+=，-=，*=，/=，%=【a +=b;等价于 a=a+b;】

```java
byte b = 3;
b += 2; //等价于 b = (byte)(b + 2);  并不是等价于 b = b + 2,假设等价于这个，那么 b + 2值类型为int 赋值给 byte会报错
b++;  //等价于 b = (byte)(b + 1);
```



###### 5.6 三元运算符

条件表达式 ？ 表达式1 ： 表达式2；

1.如果条件表达式为true，运算后的结果是表达式1；

2.如果条件表达式为false，运算后的结果是表达式2；



###### 5.7 运算符优先级

1.运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。

下面优先级（从上往下，从高到低）

| .      ()       {}       ;       ,【举例：int a=1,b=5;】 |
| -------------------------------------------------------- |
| ++       --       ~       !(date_type)                   |
| *      /      %                                          |
| +      -                                                 |
| <<      >>      >>>      位移                            |
| <      >      <=      >=      instance                   |
| ==      !=                                               |
| &                                                        |
| ^                                                        |
| \|                                                       |
| &&                                                       |
| \|\|                                                     |
| ?      :                                                 |
| =      *=      /=      %=                                |
| +=      -=      <<=      >>=                             |
| >>>=      &=      ^=      \|=                            |

```markdown
简单记忆上面的优先级由高到低：
1）(),{}等
2）单目运算符
3）算术运算符
4）位移运算符
5）比较运算符
6）逻辑运算符
7）三元运算符
8）赋值运算符

```

###### 5.8 标识符规则

1. Java对各种变量、方法和类等命名时使用的字符序列称为标识符
2. 凡是自己可以起名字的地方都叫标识符

> 标识符的命名规则（必须遵守）

1. 由26个英文字母大小写，0-9，_或$组成
2. 数字不可以开头。
3. 不可以使用关键字和保留字，但能包含关键字和保留字
4. Java严格区分大小写，长度无限制
5. 标识符不能包含空格



> 标识符的命名规范（建议这样使用）

1. `包名`：多单词组成时所有字母都小写：aaa.bbb.ccc //比如：com.wing.crm
2. `类名`、`接口名`：多单词组成，所有单词首字母大写：XxxYyyZzz，如TankShotGame
3. `变量名`、`方法名`：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： xxxYyyZzz，如：tankShotGame
4. `常量名`：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ,如：TAX_RATE



###### 5.9 键盘输入

```java
Scanner scanner = new Scanner(System.in);
System.out.println("请输入：");
String name = scanner.next();  // 这里会等待键盘输入
System.out.println("name=" + name);
```



 ##### 6 进制

###### 6.1 进制介绍

对于整数，有四种表示方式：

1. `二进制`：0,1 满2进1，以0b或0B开头
2. `十进制`：0-9 满10进1
3. `八进制`：0-7 满8进1,以数字0开头表示
4. `十六进制`：0-9以及A-F，满16进1，以0x或0X开头表示，此处A-F不区分大小写

```java
/* 演示四种进制 */
// 二进制（0b开头）
int n1 = 0b1010;  // 10
// 十进制
int n2 = 1010;    // 1010
// 八进制 （0 开头）
int n3 = 01010;   // 520
// 十六进制（0x开头）
int n4 = 0x1010;  // 4112

//进制计算器：https://www.matools.com/app/radix
```

###### 6.2 进制的转换(略)

###### 6.3 原码、反码和补码

1. 二进制的最高位是符号位：0表示正数，1表示负数
2. 正数的原码，反码，补码都一样（三码合一）
3. 负数的反码 = 它的原码符号位不变，其他位取反
4. 负数的补码=它的反码 + 1，负数的反码 = 负数的补码 - 1
5. 0的反码，补码都是0
6. Java没有无符号数，换言之，Java中的数都是有符号的
7. 在计算机运算的时候，都是以`补码的方式来运算`的（重点）
8. 当我们看运算结果时，要看它的`原码`（重点）

###### 6.4 位运算符

Java中有7个位运算符（&、|、^、~、>>、<< 和 >>>）

分别是 **按位与&、按位或|、按位异或^、按位取反~**，它们的运算规则是：

- 按位与&：两位全为1，结果为1，否则为0
- 按位或|：两位有一个为1，结果为1，否则为0
- 按位异或^：两位一个为1，一个为0，结果为1，否则为0
- 按位取反~：0变1，1变0

```java
/** 计算机所有的运算都是使用"补码"来进行的 */
// 第一步：先得到2的原码（int是四个字节）：00000000 00000000 00000000 00000010 ，因为正数三码合一，所以补码也是这个
// 2的补码：00000000 00000000 00000000 00000010
// 第二步：先得到3的原码：00000000 00000000 00000000 00000011，
// 3的补码：00000000 00000000 00000000 00000011
// 计算 2&3 ： 00000000 00000000 00000000 00000010
//          & 00000000 00000000 00000000 00000011
//          --------------------------------------
// 得到补码结果 00000000 00000000 00000000 00000010，因为符号位为0，所以反码、原码结果和补码相同（看结果要看原码）
// 原码结果    00000000 00000000 00000000 00000010
System.out.println(2&3);  // 2
// 第一步：先得到-2的原码 10000000 00000000 00000000 00000010
// 第二步：计算-2的反码   11111111 11111111 11111111 11111101
// 第三步：计算-2的补码   11111111 11111111 11111111 11111110 （有了补码就可以计算了）
// 第四步：计算 ~-2结果   00000000 00000000 00000000 00000001 （结果是补码，很幸运，补码符号位是正数，所以三码合一）
System.out.println(~-2);  // 1
// 第一步：先得到2的补码   00000000 00000000 00000000 00000010 （三码合一）
// 第二步：计算 ~2结果    11111111 11111111 11111111 11111101 （结果符号位是负数）
// 第三步：计算对应的补码  11111111 11111111 11111111 11111100 （结果符号位是负数）
// 第四步：计算对应的原码  10000000 00000000 00000000 00000011
System.out.println(~2);  // 3
```

还有3个位运算符： **>>、<<、>>>**，它们的运算规则是：

- 算术右移 >>：低位溢出，符号位不变，并用符号位补溢出的高位
- 算术左移 <<：符号位不变，低位补0
- 逻辑右移 >>>：也叫无符号右移，运算规则是：低位溢出，高位补0
- 正数的无符号右移和右移结果相同(例：12>>>2 = 12>>2)
- 特别说明：没有 <<< 符号

```markdown
int a=1>>2  => 00000001 => 00000000 本质 1/2/2=0
int a=1<<2  => 00000001 => 00000100 本质 1*2*2=4
```

```java
//12的源码: 00000000 00000000 00000000 00001100
        // 左移两位:00000000 00000000 00000000 00110000 本质 12 * 2 * 2 = 48
        System.out.println(12 << 2);  // 48

        //12的源码: 00000000 00000000 00000000 00001100
        //右移两位:00000000 00000000 00000000 00000011 本质 12 / 2 / 2 = 3
        System.out.println(12 >> 2);  // 3

        //-12的源码: 10000000 00000000 00000000 00001100
        //左移两位:  10000000 00000000 00000000 00110000 本质 -12 * 2 * 2 = -48
        System.out.println(-12 << 2); // -48

        //-12的源码: 10000000 00000000 00000000 00001100
        //右移两位:10000000 00000000 00000000 00000011 本质 -12 / 2 / 2 = -3
        System.out.println(-12 >> 2); // -3

// -16的源码:  10000000 00000000 00000000 00010000
        // -16的反码:  11111111 11111111 11111111 11101111
        // -16的补码:  11111111 11111111 11111111 11110000
        // -16 >>> 2结果:  11111111 11111111 11111111 11111100
        System.out.println(-16 >>> 2);  // 1073741820
```



 ##### 7 控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，是程序员必须掌握的。有三大流程控制语句分别是：顺序控制、分支控制和循环控制。

###### 7.1 顺序控制

程序从上到下逐行执行，中间没有任何判断和跳转。

###### 7.2 分支控制（if, else, switch）

> 单分支

```java
// 基本语法
if(条件表达式){
  执行代码块；
}

// 说明：当条件表达式为true时，就会执行{}的代码，如果为false，就不执行，特别说明，如果{}中只有一条语句，则可以不用{}，建议写上{}
```

> 双分支

```java
// 基本语法
if(条件表达式){
  执行代码块1；
}else{
  执行代码块2；
}

// 说明：当条件表达式为true时，执行代码块1;否则，执行代码块2
```

> 多分支

```java
// 基本语法
if(条件表达式1){
  执行代码块1；
}else if(条件表达式2){
  执行代码块2；
}
......
else{
  执行代码块3；
}

// 说明：
//1、当条件表达式1为true时，执行代码块1;
//2、当条件表达式1为false时，才去判断条件表达式2是否为true;
//3、如果条件表达式2为true时，执行代码块2;
//4、以此类推，如果所有的表达式都不成立
//5、则执行else的代码块
```

> switch分支结构

```java
// 基本语法
switch(表达式){
    case 常量1:
    语句块1;
    break;
    case 常量2:
    语句块2;
    break;
    case 常量3:
    语句块3;
    break;
    ...
    case 常量n:
    语句块n;
    break;
    default:
    语句块default
    break;
}

// 说明：
//1、switch关键字，表示switch分支
//2、表达式对应一个值
//3、当表达式的值等于常量1，就执行语句块1
//4、break：表示退出switch
//5、如果和case常量1匹配，就执行语句块1，如果没有匹配，就继续匹配case 常量2
//6、如果一个都没有匹配上，执行 default

// 注意：假如switch case 常量1和 case 常量2 里面漏了写break，那么会出现这样的现象，如果表达式的值与常量1匹配，那么会先执行完语句块1，因为没有写break，所以会继续往下面执行（此时不会判断下面的case 2中的常量值），直接执行语句块2，因为case 常量2 里面也没有写break，所以会继续执行 语句块3，此时因为case 常量3 里面有break，所以会停止。
【总结：如果匹配上了case里面的常量之后，会一直执行下面的case里面的语句（不会再进行判断），直到遇到break跳出，如果都没有break，则语句块default也会执行】// 这个比较坑需要注意
```

> switch细节点

1. 表达式数据类型，应和case后的常量`类型一致`,或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是 int
2. switch(表达式)中的表达式的返回值必须是：(byte,short,int char enum,String)
3. case子句中的值必须是常量，而不能是变量
4. default子句是可选的，当没有匹配的case时执行default



> Switch 和 if的比较

1. 如果判断的具体数值不多，而且符合 (byte,short,int char enum,String) 这6种类型，建议使用switch
2. 其他情况：对区间判断，对结果为boolean类型判断，使用if



###### 7.3 循环控制(for, while, do while)

> 介绍

可以让代码循环的执行

> for循环控制

```java
//基本语法
for(循环变量初始值;循环条件;循环变量迭代){
  循环操作的语句;
}
```

> for注意事项和细节

1. 循环条件是返回一个布尔值的表达式
2. for(;循环判断条件;)中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略
3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

```java
int i = 1; // 循环变量的初始化
//for( int i = 1 ; i <= 10 ; ){  //如果这样写，那么i只能在for循环中使用
for( ; i <= 10 ; ){
  System.out.println("hello");
  i++;    // i++ 也可以写到循环体里面，不写到括号里面
}

// 循环结束后需要使用i
System.out.println(i);


//解析：为什么要将i写到外面呢？
//答：假如有个需求，就是for循环遍历完结束后还想使用变量i，所以要写到外面提升作用域
```

```java
// 死循环
for(;;){
  System.out.println("hello");
}
```

```java
// 也可以这样的写法
int count = 3;
for (int i = 0,j = 0; i < count ; i++,j+=2){
    System.out.println("i=" + i);
    System.out.println("j=" + j);
}
```



> while循环控制

```java
//基本语法
循环变量初始值;
while(循环条件){
  循环体(语句);
  循环变量迭代;
}
```

> while注意事项和细节

1. 循环条件是返回一个布尔值的表达式
2. while循环是先判断再执行语句



> do while循环控制

```java
//基本语法
循环变量初始值;
do{
  循环体(语句);
  循环变量迭代;
}while(循环条件);
```

> do while注意事项和细节

1. 先执行再判断，也就是说，一定会执行一次
2. while最后有一个分号

###### 7.4 break

> 跳转控制语句break

break语句用于终止某个语句块的执行，一般使用在switch或者循环中

```java
//基本语法
{
  ......
  break;
  ......
}
```

> break注意事项和细节

1. break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块
2. 开发中不建议使用标签的方式

```java
wing1:  // 这是标签名，可自定义
for (int i = 0; i < 10; i++) {
wing2:  // 这是标签名，可自定义
    for (int j = 0; j < 5; j++) {
        if(i == 2){
            //break;   // 等价于 break wing2；（默认跳出最近的循环体）
            break wing1;   // 指定退出到某个标签位置
        }
         System.out.println("i=" + i);
    }
}
```



###### 7.5 continue

> 跳转控制语句continue

continue语句用于结束本次循环，继续执行下一次循环

continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的使用的规则一样（不演示）

```java
//基本语法
{
  ......
  continue;
  ......
}
```

```java
for (int i = 0; i < 10; i++) {
   if(i == 2){
       continue;
   }
    System.out.println("i=" + i);
}
```

###### 7.6 return

> 介绍

return使用在方法，表示跳出所在的方法，如果return写在main方法，退出程序...



 ##### 8 数组、排序和查找

###### 8.1 数组

> 案例引出,传统方式实现

```java
//需求，有六只鸡，体重分别如下，然后求平均体重
double hen1 = 3;
double hen2 = 5;
double hen3 = 1;
double hen4 = 12;
double hen5 = 3.4;
double hen6 = 6;
double totalWeight = hen1 + hen2 + hen3 + hen4 + hen5 + hen6;
double avgWeight = totalWeight / 6;
System.out.println("平均体重：" + avgWeight);
```

> 数组介绍

数组可以存放多个`同一类型`的数据，数组也是一种数据类型，是引用类型。

```java
//解决传统方式 - 数组静态初始化方式
double[] hens = {3,5,1,12,3.4,6};
double totalWeight = 0.0;
for (int i = 0; i < hens.length; i++) {
    totalWeight += hens[i];
}
double avgWeight = totalWeight / 6;
System.out.println("平均体重：" + avgWeight);
```

> 数组的使用

> 使用方式1-动态初始化

```java
语法：数据类型 数组名[] = new 数据类型[大小];
    或者 数据类型[] 数组名 = new 数据类型[大小];
例：int[] a = new int[10];  // 创建了一个数组，名字a，存放5个int，默认值都是0

```

> 使用方式2-动态初始化

```java
第一步：先声明数组
  语法：数据类型 数组名[];也可以，数据类型[] 数组名;
例：int a[]; 或者 int[] a;
  
第二步：创建数组
  语法：数组名 = new 数据类型[大小];
例：a = new int[10];

// 问：什么情况会先声明再分配大小呢？
// 答：可能在 for循环外面先声明，但还不知道数组的长度大小，在for循环里面满足某个条件才知道长度是多少，for循环里面才创建数组的大小。
```

> 使用方式3-静态初始化

```java
// 当知道数组有多少个元素，并且也知道具体值，可以使用该方式
语法：数据类型[] 数组名 = {元素值，元素值...}
例：int a[] = {1,2,4,5,8};
```

> 数组使用注意事项和细节

1. 数组是多个`相同类型`数据的组合，实现对这些数据的统一管理
2. 数组中的元素可以是任何数据类型，包括`基本类型`和`引用类型`，但是`不能混用`
3. 数组创建后，如果没有赋值，有默认值 int->0,short->0,byte->0,long->0,float->0.0,double->0.0,char \u0000,boolean -> false,String null



> 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响（int n1 = 2;int n2 = n1;）
2. 数组在默认情况下是引用传递，赋的值是地址

```java
// 值传递
int n1 = 10;
int n2 = n1;
n2 = 80;
System.out.println("n1=" + n1);
System.out.println("n2=" + n2);
// 引用传递
int[] arr1 = {1,2,3};
int[] arr2 = arr1;
arr2[0] = 100;
for (int i = 0; i < arr1.length; i++) {
    System.out.println("arr1=" + arr1[i]);
}
for (int j = 0; j < arr2.length; j++) {
    System.out.println("arr2=" + arr2[j]);
}
```



###### 8.2 排序

> 介绍

排序是将多个数据，依指定的顺序进行排列的过程

排序的分类：

1. 内部排序：

指将需要处理的所有数据都加载到内部存储器中进行排序，包括（`交换式排序法、选择式排序法`和`插入式排序法`）

2. 外部排序法：

数据量过大，无法全部加载到内存中，需要借助外部存储进行排序，包括（`合并排序法`和`直接合并排序法`）ps:大数据开发时会遇到



> 冒泡排序法

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始，也可以从前向后，从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部。



```java
// 值传递
int[] arr = {24,69,80,57,13,-2,0,6};
  int[] arr = {1,2,3,4,5,6,7,8};
int temp = 0;
for (int i = 0; i < arr.length - 1; i++) {
    // 记录某一轮如果都没有交换位置，说明已经排好了，直接退出
    boolean flag = true;
    for (int j = 0; j < arr.length - i - 1; j++) {
        if(arr[j] > arr[j + 1]){
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
            flag = false;
        }
    }
    if(flag){
        System.out.println("break" + i);
        break;
    }
}
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```



###### 8.3 多维数组

```java
 // 请用二维数组输出如下图形
 // 0 0 0 0 0 0
 // 0 0 1 0 0 0
 // 0 2 0 0 0 0
 // 0 0 0 3 0 0
 // 1.从定义形式上看 int[][]
 // 2.可以这样理解，原来的一维数组的每个元素是一维数组
 int [][] arr = {{0, 0, 0, 0, 0, 0},
                 {0, 0, 1, 0, 0, 0},
                 {0, 2, 0, 0, 0, 0},
                 {0, 0, 0, 3, 0, 0}};
 for (int i = 0; i < arr.length; i++) {
     for (int j = 0; j < arr[i].length; j++) {
         System.out.print(arr[i][j] + " ");
     }
     System.out.println();
 }
```



 ##### 9 面向对象编程（基础）

###### 9.1 类与对象

比如：猫有很多种类，但是猫都有属性和行为，然后将这些共有的属性抽取到一个类中，这就是猫类，可以通过猫类new出具体的对象，比如new出田园猫，橘猫等等。具体的就是对象。



> 类与对象的区别和联系

1. 类是抽象的，概念的，代表一类事物，比如人类，猫类...，即它是数据类型
2. 对象是具体的，实际的，代表一个具体事物，即是实例
3. 类是对象的模板，对象是类的一个个体，对应一个实例



> 成员变量/属性的注意事项和细节

1. 属性的定义语法同变量，示例：访问修饰符 属性类型 属姓名；
2. 属性的定义类型可以为任意类型，包含基本类型或引用类型
3. 属性如果不赋值，有默认值( int->0,short->0,byte->0,long->0,float->0.0,double->0.0,char \u0000,boolean -> false,String null)

`代码 org.example.classtest.PropertiesDetail `



> 如何创建对象

```java
1. 先声明再创建
Person p1; // 在栈先声明一个变量p1，该变量p1指向的地址为空（还没开辟空间，new才会开辟空间）
p1 = new Person(); // 在堆内存开辟空间（开辟空间就有地址）,然后把地址填到上面p1指向的地址中

2. 直接创建
Person p1 = new Person();
```

> 类和对象的内存分配机制（Java内存的结构分析）

1. 栈：一般存放基本数据类型（局部变量）
2. 堆：存放对象（Person p1，数组等）
3. 方法区：常量池（常量，比如字符串），类加载信息



###### 9.2 成员方法

> 介绍

在某些情况下，我们需要定义成员方法（简称方法）)。比如人类除了有一些属外（年龄，姓名),我们人类还有一些行为比如：可以说话，跑步...通过学习，还可以做算术题。这时就需要用成员方法才能完成。

> 成员方法的定义

```java
访问修饰符 返回数据类型 方法名（形参列表...）{
  语句；
  return 返回值；
}
```

> 成员方法的好处

1. 提高代码的复用性
2. 可以将实现的细节封装起来，然后供其他用户来调用即可

> 方法调用小结

1. 【最开始main方法开始执行也会开辟一个main方法的栈空间】﻿﻿﻿当程序(main方法)执行到方法(getSum())时，就会开辟一个getSum方法独立的空间(栈空间)
2. ﻿﻿﻿当方法getSum执行完毕，或者执行到return语句时．就会返回（开辟的getSum栈空间会被销毁）

3. 返回到调用方法的地方
4. 返回后，继续执行方法后面的代码（main代码也执行完的话，main方法的栈空间也会销毁）
5. 当main方法（栈）执行完毕，整个程序退出
6. 调用方法时，如果传进去的是基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参
7. 调用方法时，如果传进去的是引用数据类型，传递的是地址值，形参的任何改变会影响实参

> 成员方法的注意事项和细节

1. 如果方法是 void 则方法体中可以没有return语句，或者只写 return 
2. 返回类型可以是任意类型，包含基本类型或引用类型

```java
// 返回int 可以使用double ，自动转换类型
double d1 = getInt();
double d2 = getDou(); 


public static int getInt(){
     int n = 100;
     return n; // 返回int类型
 }
 public static double getDou(){
     int n = 100;
     return n;  // 方法返回值是double ,真实返回int类型
 }
```



> 方法调用细节说明

1. 同一个类中的方法调用：直接调用即可。
2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如 对象名.方法名(参数);

```java
// 同一个类中的方法调用：直接调用即可
class A{
    public void print(int n){
        System.out.println(n);
    }
    public void sayOk(){
        print(1);
    }
}

// 跨类中的方法A类调用B类方法：需要通过对象名调用
class A{
    public void print(int n){
        System.out.println(n);
    }
    public void sayOk(){
        print(1);
    }
}
class B{
    public void sayOk(){
        A a = new A();
        a.print(2);
    }
}
```

> 方法递归调用-介绍

递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂问题，同时可以让代码变得简洁

```java
// 求阶乘 5 * 4 * 3 * 2 * 1 = 120
public static int factorial(int n){
    if(n == 1){
        return 1;
    }else{
        return factorial(n - 1) * n;
    }
}

// 斐波那契数 1,1,2,3,5,8,13,21...
public static int test1(int n){
    if(n < 3){
        return 1;
    }
    return (test1(n - 1) + test1(n - 2));
}
```

> 递归重要规则

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间）
2. 方法的局部变量是独立的，不会相互影响，比如n变量
3. 如果方法中使用的是引用类型变量(比如数组），就会共享该引用类型的数据
4. 送归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕



> 老鼠找迷宫

1. findway方法就是专内来找出迷宫的路径
2. 如果找到，就返回 true，否则返回false
3. map 就是二维数组，即表示迷宫
4. i,j 就是老鼠的位置，初始化的位置为(1,1）
5. 因为我们是递归的找路，所以我先规定 map数组的各个值的含义(日0表示可以走 1表示障碍物 2 表示可以走 3 表示走过，但是走不通是死路)
6. 当map[6][5〕 =2 就说明找到通路，就可以结束，否则就继续找
7. 先确定老鼠找路策略下->右->上->左

```java
视频：https://www.bilibili.com/video/BV1fh411y7R8?p=224&vd_source=dc02a4c6e2a8e915fb8ee431999e5b2c
```



###### 9.3 成员方法传参机制（重要）

###### 9.4 方法重载overload

> 介绍

java中允许同一个类中，多个`同名方法`的存在，但要求 形参列表不一致

> 注意事项和细节

1. 方法名：必须相同
2. 参数列表：必须不同（参数类型或个数或顺序，至少有一样不同，参数名无要求）
3. 返回类型：无要求



###### 9.5 可变参数

> java允许将同一个类中多个同名同功能但`参数个数不同`的方法，封装成一个方法

```java
// 基本语法
访问修饰符 返回类型 方法名(数据类型…形参名）{
}
```

> 可变参数引出案例

```java
// 求两个数的和
public static int sum(int n1,int n2){
    return n1 + n2;
}
// 求三个数的和
public static int sum(int n1,int n2,int n3){
    return n1 + n2 + n3;
}
// 求四个数的和
public static int sum(int n1,int n2,int n3,int n4){
    return n1 + n2 + n3 + n4;
}
```

> 优化上面的方法

上面的三个方法名称相同，功能相同，参数个数不同

```java
 System.out.println(sum()); // 0
 System.out.println(sum(1)); // 1
 System.out.println(sum(1,2)); // 3
 System.out.println(sum(1,2,3));  // 6

// 求多个数的和
 public static int sum(int... nums ){
     int totalNum = 0;
     for (int i = 0; i < nums.length; i++) {
         totalNum += nums[i];
     }
     return totalNum;
 }

/* 也可以传一个数组 */
int[] arr = {1,2,3,9};
System.out.println(sum(arr)); // 15


/* 可变参数和普通参数一起，但可变参数要在最后 */ 
int[] arr = {1,2,3,9};
System.out.println(sum("test",arr));

public static int sum(String str,int... nums ){
    int totalNum = 0;
    System.out.println(str);
    for (int i = 0; i < nums.length; i++) {
        totalNum += nums[i];
    }
    return totalNum;
}
```

> 可变参数注意事项和使用细节

1. 可变参数的实参可以为0个或任意多个
2. 可变参数的实参可以为数组。
3. 可变参数的本质就是`数组`
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
5. 一个形参列表中只能出现一个可变参数



###### 9.6 作用域

> 基本介绍

1. 在java编程中，主要的变量就是属性(成员变量）和局部变量（方法中和代码块中）。
2. 我们说的`局部变量`一般是指在`成员方法`中定义的变量
3. java中作用域的分类
    全局变量：也就是属性，作用域为整个类体 Cat类：cry eat 等方法使用属性
4. 全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值



```java
class Cat{
    // 全局变量也就是属性，作用域为整个类体，属性定义时可以直接赋值
    int age = 10;
    // 全局变量（属性）可以不赋值，直接使用，因为有默认值
    double weigth;
    public void cry(){
        // 1. 局部变量一般是指在成员方法中定义的变量
        // 2. n 和 name 就是局部变量
        // 3. n 和 name的作用域在 cry 方法中
        int n = 10;
        String name = "jack";
        double test;
        // 全局变量未赋值可以直接使用，有默认值
        System.out.println(weigth);
        // 局部变量未赋值不可以直接使用
        System.out.println(test);  
    }
}
```

> 作用域的注意事项和细节

1. 属性和局部变量可以重名，访问时遵循就近原则。
2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名
3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中生效
4. 作用域范围不同
    全局变量：，可以被本类使用，或其他类使用（通过对象调用）
    局部变量：只能在本类中对应的方法中使用
5. 修饰符不同
    全局变量/属性可以加修饰符
    局部变量不可以加修饰符



###### 9.7 构造器/构造方法

> 基本介绍

构造方法又叫构造器，是类的一种特殊的方法，它的主要作用是完成对`新对象的初始化`(构造器只是对，对象的属性进行初始化，并不是创建对象，也就是说，执行构造器前，对象已经创建好了并且属性已经有了初始值)

> 基本语法

```java
[修饰符〕方法名(形参列表）{
		方法体;
}
```

> 基本说明

1. 构造器的修饰符可以默认
2. 构造器`没有返回值`，也不能写void
3. `方法名` 和`类名字`必须一样
4. 参数列表 和 成员方法一样的规则
5. 构造器的调用由系统完成
6. 一个类可以定义多个不同的构造器，即构造器重载
7. 如果程序没有定义构造方法，系统会自动给类生成一个默认无参构造方法(也叫默认构造方法）
8. 一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下



> 创建对象的过程 

```java
class Person{
  int age = 90;
  String name;
  Person(String n,int a){
    name = n;
    age = a;
  }
}

Person p = new Person("Wing",20);
```

1. 加载Person类信息(Person.class)，只会加载一次
2. 在堆中分配空间(地址）
3. 完成对象初始化 【3.1 默认初始化 age=0 name=null 3.2 显式初始化age=90,name=null, 3.3构造器的初始化 age =20,name=Wing】
4. 在对象在堆中的地址,返回给p



###### 9.8 this

哪个对象调用，this 就代表哪个对象

```java
// 可以简单将 hashCode 理解成对象的地址
class Person{
    String name;
    int age;
    public Person(String name,int age){
        this.age = age;
        this.name = name;
        System.out.println("this 的hashCode:" + this.hashCode());
    }
}

Person p1 = new Person("wang",19);
System.out.println("p1 的hashCode:" + p1.hashCode());
Person p2 = new Person("li",18);
System.out.println("p2 的hashCode:" + p2.hashCode());

//输出结果
this 的hashCode:901506536
p1 的hashCode:901506536
this 的hashCode:747464370
p2 的hashCode:747464370
```

> this的注意事项和细节

1. this关键字可以用来访问本类的`属性`、`方法`、`构造器`
2. this用于区分当前类的属性和局部変量
3. ﻿﻿﻿访问成员方法的语法：this.方法名（参数列表);
4. ﻿﻿﻿访问构造器语法：this(参数列表)；注意只能在构造器中使用(**注意：有这样的语法则this()必须放在构造器的第一条语句**)
5. this不能在类定义的外部使用，只能在`类定义的方法中`使用



 ##### 10 面向对象编程（中级）

###### 10.1 包

> 包的三大作用

1. 区分相同名字的类
2. 当类很多时,可以很好的管理类
3. 控制访问范围

> 包的本质

包的本质 实际上就是创建不同的文件夹/目录，来保存类文件



> 包的命名规则

只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字

> 包的命名规范

一般是小写字母 + 小圆点，一般是：com.公司名.项目名 业务模块名，举例如下：

1. com.sina.crm.user //用户模块
2. com.sina.crm.order //订单模块
3. com.sina.crm.utils//工具类

> 常用的包

一个包下,包含很多的类,java中常用的包有：

- java.lang.*   //lang包是基本包，默认引入，不需要再引入
- java.util.*    //util 包，系统提供的工具包，工具类，使用 Scanner
- java.net.*   //网络包，网络开发
- java.awt.*  //是做java的界面开发，GUI

```java
// 注意：需要使用哪个类，就导入哪个类即可，不建议使用*号全导入

import java.util.Scanner;  // 表示只会引入 Scanner 这个类
import java.util.*;  // 表示将 java.util 包下的所有类引入
```

> 注意事项和使用细节

1. package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package
2. import指令 位置放在package的下面，在类定义前面,可以有多句且没用顺序要求



###### 10.2 访问修饰符

> 基本介绍

java提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）

1. 公开级别;用`public` 修饰,对外公开
2. ﻿﻿﻿受保护级别：用`protected`修饰,对子类和同一个包中的类公开
3. ﻿﻿﻿默认级别;没有修饰符号,向同一个包的类公开.
4. ﻿﻿﻿私有级别：用`private`修饰,只有类本身可以访问,不对外公开.

> 四种访问修饰符的访问范围

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 不同包的子类 | 不同包 |
| -------- | -------------- | ---- | ---- | ------------ | ------ |
| 公开     | public         | √    | √    | √            | √      |
| 受保护   | protected      | √    | √    | √            | x      |
| 默认     | 没有修饰符     | √    | √    | x            | x      |
| 私有     | private        | √    | x    | x            | x      |



> 使用注意事项

1. 修饰符可以用来修饰类中的属性，成员方法以及类
2. 只有`默认`的和`public`才能修饰类！，并且遵循上述访问权限的特点
3. 成员方法的访问规则和属性完全一样



###### 10.3 封装

面向对象的三大特征：封装，继承和多态

> 封装介绍

封裝(encapsulation)就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起,数据被保护在内部,程序的其它部分只有通过被授权的操作【方法】,才能对数据进行操作

> 封装的理解和好处

1. 隐藏实现细节
2. 可以对数据进行验证，保证安全合理

> 封装实现的三步

1. 将属性进行私有化private【不能直接修改属性】
2. 提供一个公共的(public)set方法，用于对属性判断井赋值（set方法里面可以加入数据验证的业务逻辑）
3. 提供一个公共的(public)get方法，用于获取属性的值

###### 10.4 继承

###### 10.5 多态

###### 10.6 Super

###### 10.7 overwrite

###### 10.8 Object类详解







#####  作业

> 1、JDK,JRE,JVM的关系

1. JDK = JRE + Java开发工具
2. JRE = JVM + 核心类库

> 2、基本数据类型转换练习题

```java
short s = 12; // ok
s = s-9; //错误 int -> short

byte b = 10; // ok
b = b + 11;  //错误 int -> byte
b = (byte)(b + 11); // ok ,使用强转

char c = 'a'; //ok
int i = 16;  // ok
float d = .314F; // ok
double result = c + i + d; // ok, float -> double

byte b = 16; //ok
short s = 14; //ok
short t = s + b;// 错误 int -> short

double num3 = 3d;  //ok
double num4 = 8;  // ok int -> double
```

> 3、算术运算符面试题

```java
# ++在后面
int i = 1;
i = i++;
System.out.println(i);  // 请问这里输出什么 答案：1
// 解析：i = i++; 这一行程序执行时会使用临时变量分三步：1)temp=i; 2)i=i+1; 3)i=temp;

# ++在前面
int i = 1;
i = ++i;
System.out.println(i);// 请问这里输出什么  答案：2
// 解析：i = ++i; 这一行程序执行时会使用临时变量分三步：1)i=i+1; 2)temp=i; 3)i=temp;【注意这里的顺序是先执行i=i+1】

```

> 4、数组练习

```java
// 创建一个 char 类型的26个元素的数组，分别放置 'A' - 'Z'
// 使用for循环访问所有的元素并打印
char[] chars = new char[26];
for (int i = 0; i < chars.length; i++) {
    chars[i] = (char) ('A' + i);
}
for (int i = 0; i < chars.length; i++) {
    System.out.println(chars[i]);
}
```

> 5、使用Arrays对数组进行排序

```java
import java.util.Arrays;

int[] arr = {-1,3,78,23,5};
Arrays.sort(arr);
```





























































##### java API在线文档

> 这个网站很强大，里面有很多技术的文档

https://www.matools.com/

https://www.matools.com/api/java8













































